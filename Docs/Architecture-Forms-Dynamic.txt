
---

# ✅ **Architecture-Forms-Dynamic.txt**

```text
Hippocrates 360 – Dynamic Forms Architecture (FMX)

Този документ описва архитектурата на динамичните форми – новият механизъм, който заменя
статичните екрани на стария Хипократ.

====================================================================
1. Проблемът със старите форми
====================================================================

Старият механизъм използваше статични екрани върху картинка. Това създава проблем:
- няма мащабиране
- няма динамика
- нови изисквания не могат да се добавят
- големи номенклатури като "дългосрочна грижа" няма къде да се визуализират
- различно съдържание според възраст/пол прави екрана невъзможен за поддържане

Новите динамични форми решават проблема изцяло.

====================================================================
2. Концепция за динамичния UI
====================================================================

Всички динамични екрани се изграждат от ЕДИН контейнер: FmxControls.pas/fmx.

Този контейнер съдържа:
- шаблони (Layout-и)
- стилове
- popup-и
- анимации
- контролни елементи

Всичко реално показвано се КЛОНИРА от тези шаблони.

====================================================================
3. Основен принцип: Clone → Bind → Reuse
====================================================================

Шаблоните са Layout-и:

lytEdit          – едитор (число/текст)
lytMemo          – memo поле
lytComboDyn      – single combo
lytMultiCombo    – multi combo
lytDate          – дата
lytCheckDyn      – checkbox

При нужда:

1) Клонираме Layout-а
2) Намираме вътрешните контроли чрез WalkChildren
3) Обвързваме контролите с LNK възела
4) Слагаме събития
5) Добавяме към родителски Layout

При следващо генериране контролите НЕ СЕ ИЗТРИВАТ – само се откачат (Parent := nil) и се преизползват.

====================================================================
4. Разпознаване на вътрешни контроли
====================================================================

FMX не дава автоматични имена след клониране.
Затова има WalkChildren функции:

WalkChildrenCheck
WalkChildrenEdit
WalkChildrenRect
WalkChildrenText
WalkChildrenAnim
...

Те обхождат дървото на FMX компоненти и връщат желания тип.

След това данните се събират в клас:

TEditLabel, TMemoLabel, TComboOneLabel, TComboMultiLabel, ...

Всеки такъв клас държи:
- всички контролчета вътре
- референция към LNK възела
- номенклатурна информация
- събития

====================================================================
5. Връзката UI ↔ LNK възел
====================================================================

Най-важният момент в архитектурата:

Всеки UI контрол знае КОЙ ВЪЗЕЛ в LNK дървото го е създал.

Пример:

TempEditLabel.node := RunNodeCL132;

Така:

Контрол → node → data → DataPos → ADB → стойност

При Paint / Validating:

TempEditLabel := TEditLabel(TEdit(Sender).Parent.TagObject);
node          := TempEditLabel.node;
data          := pointer(PByte(node) + lenNode);

После UI взима real-time стойност от ADB.

====================================================================
6. Генериране според CL134
====================================================================

CL134 номенклатура дефинира какъв контрол да се генерира.

'1' → числова стойност
'2' → номенклатура (single/multi)
'3' → описателно (memo)
'4' → дата
'5' → boolean

Така UI се генерира изцяло от номенклатури.

====================================================================
7. Връзка между дърво и UI – VibroControl
====================================================================

При избор на възел в дървото:

FmxProfForm.VibroControl(node);

VibroControl обхожда всички контролни списъци и търси:

if TempCheckLYT.node = node then ...

След което:
- позиционира скрола
- визуално маркира контрола
- (в бъдеще) ще добави „вибро“ ефект

====================================================================
8. Характеристики на динамичните форми
====================================================================

- Неограничен брой контроли
- Работят бързо (повторно използване)
- UI е отделен от данните
- Данните идват само от ADB
- Поведението идва от CL134
- Поддръжката е лесна и централизирана

====================================================================
9. Какво може да се разшири
====================================================================

- диаграми
- примерни анимации
- подробно описание на SourceAnsw
- архитектурна схема UI↔LNK↔ADB
- разширяване към мобилни устройства

====================================================================
Край
====================================================================
